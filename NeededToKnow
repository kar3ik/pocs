virtualloc, rtlmovemomery, createthread write a shell code to run by using above three apis to run code in memory from vba
calling win32 apis in vba

virtualloc, rtlmovemomery, createthread write a shell code to run by using above three apis to run code in memory from powershell
calling win32 apis in powershell


what are assemblies
[appdomain]::currentdomain.getassemblies()

[appdomain]::currentdomain.getassemblies() | Sort-Object -Property fullname | Format-Table fullname

what are unmanaged dll
how to locate functions in unmanaged dll
dynamic lookup in c
to perform dynamic lookup function address by win32 apis
GetModuleHandle 
GetProcAddress  

how to get assembies in specifc process (ex - powershell process)



$Assemblies = [ApDomain]::CurrentDomain.GetAssemblies()

$Assemblies |
	ForEach-Objecy {
		$_.GetTypes() |
			ForEach-Object {
				$_. | Get-Member -Static | Where-Object {
				  $_.TypeName.Contains('Unsafe')
			}
		} 2 > null
   }

whn c# code wants to directly invoke win32 api it must provides the unsafe keyword
if any functions are to be used they must be declared as static to avoid instantion 





$Assemblies = [AppDomain]::CurrentDomain.GetAssemblies()

$Assemblies | ForEach-Object {
    $_.Location
    $_.GetTypes() | ForEach-Object {
        $_ | Get-Member -Static | Where-Object {
            $_.TypeName -eq 'Microsoft.Win32.UnsafeNativeMethods'
        }
    } 2> $null
}








$systemdll = ([AppDomaiin]::CurrentDomain.GetAssemblies() | Where-Object {
  $_.GlobalAssemblyCachr -And $_.Location.Split('\\')[-1].Equals('System.dll')})

$unsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods')
$GetModuleHandle = $unsafeObj.GetMethod('GetModuleHandle')
$GetModuleHandle.Invoke($null, @("user32.dll"))






$unsafeObj.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress") {$_}}







$systemdll = ([AppDomaiin]::CurrentDomain.GetAssemblies() | Where-Object {
  $_.GlobalAssemblyCachr -And $_.Location.Split('\\')[-1].Equals('System.dll')})

$unsafeObj = $systemdll.GetType('Microsoft.Win32.UnsafeNativeMethods')
$GetModuleHandle = $unsafeObj.GetMethod('GetModuleHandle')
$user32 = $GetModuleHandle.Invoke($null, @("user32.dll"))
$tmp=@()
$unsafeObj.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress" {$tmp+=$_}}
$GetProcAddress = $tmp[0]
$GetProcAddress.Invoke($null, @($user32, "MessageBoxA"))







functionLookup.ps
-----------------

function LookupFunc{
	Param ($moduleName, $functionName)
	$assem = ([AppDomain]::CurrentDomain.GetAssemblies() |
	Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split('\\')[-1].
	Equals('System.dll') }).GetType('Microsoft.win32.UnsafeNativeMethods')
	tmp=@()
	$assem.GetMethods() | ForEach-Object {If($_.Name -eq "GetProcAddress" {$tmp+=$_}}
	return $tmp[0].Invoke($null , @(($assem.GetMethod('GetModuleHandle')).Invoke($null, @($moduleName)), $functionName))

}

$MessageBoxA = LookupFunc user32.dll MessageBoxA
